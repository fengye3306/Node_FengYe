# GPIB

> 本文章使用:NI-488.2协议  

协议下载地址:`https://www.ni.com/zh-cn/support/downloads/drivers/download.ni-488-2.html#544048`

## 名词解读  

> 设备 （device）   

在 GPIB 系统中，"设备"（device）通常指那些与主控器进行交互的从设备，如仪器、传感器或测试设备。这些设备通常是GPIB总线上的从属设备，负责响应控制器的命令或请求，并发送或接收数据。

> 控制器（board）

控制器（controller）在 GPIB 系统中是负责管理总线和设备的主设备。控制器一般是计算机上安装的 GPIB 接口卡或主板上的通信模块，因此用 brd（board）来表示它。控制器的角色通常是在整个通信过程中控制总线的流程，比如处理设备间的中断、同步数据传输等。  

## 全局状态字

对于访问 NI4882 API 的应用程序，每次 NI-488.2 调用都会更新三个全局函数，以反映您正在使用的设备或板卡的状态。这些全局状态函数包括状态字（Ibsta）、错误函数（Iberr）和计数函数（Ibcnt）。它们包含有关应用程序性能的有用信息。您的应用程序应在每次 NI-488.2 调用后检查这些函数。   

### 通信状态字-Ibsta

Ibsta 是 GPIB（通用接口总线）的状态字，它包含了有关 GPIB 及其硬件状态的信息。  
Ibsta 中存储的值是所有传统 NI-488.2 调用（除了 ibfind 和 ibdev）的返回值。你可以检查 Ibsta 中的各个状态位，并利用这些信息来确定应用程序的下一步操作。
`Ibsta`是一个十六位数，每一位都表征了一个状态字。

`unsigned int **ThreadIbsta** ()`,通过ThreadIbsta 函数返回当前执行线程的 `Ibsta` 值。

| 助记符 | 位  | 十六进制 | 类型     | 描述                   |
| ------ | --- | -------- | -------- | ---------------------- |
| **ERR**  | 15  | 8000     | dev, brd | NI-488.2 错误       |
| **TIMO** | 14  | 4000     | dev, brd | 超过时间限制            |
| **END**  | 13  | 2000     | dev, brd | 检测到 END 或 EOS     |
| **SRQI** | 12  | 1000     | brd      | 收到 SRQ 中断           |
| **RQS**  | 11  | 800      | dev      | 设备请求服务            |
| **CMPL** | 8   | 100      | dev, brd | 输入/输出操作完成       |
| **LOK**  | 7   | 80       | brd      | 锁定状态                |
| **REM**  | 6   | 40       | brd      | 远程状态                |
| **CIC**  | 5   | 20       | brd      | 控制器占用状态          |
| **ATN**  | 4   | 10       | brd      | 断言 Attention 信号     |
| **TACS** | 3   | 8        | brd      | 讲话者状态              |
| **LACS** | 2   | 4        | brd      | 听话者状态              |
| **DTAS** | 1   | 2        | brd      | 设备触发状态            |
| **DCAS** | 0   | 1        | brd      | 设备清除状态            |

* ERR (错误位): 指示是否发生错误。如果 ERR 位被设置，说明在执行过程中出现了问题，这时需要通过 Iberr() 获取错误代码以确定具体问题。
* TIMO (超时位): 表示操作超时。如果设置了 TIMO 位，说明设备在指定的时间内没有完成操作，这对调试时间相关的问题非常重要。
* END (结束位): 表示检测到结束（END）或结束序列（EOS）。这对于读取数据流时非常重要，能帮助判断数据的完整性。
* SRQI (SRQ 中断位): 表示接收到服务请求（SRQ）。这可以帮助确定设备是否需要进一步的服务。
* RQS (请求服务位): 指示设备请求服务，可以在多设备的环境中使用。
* CMPL (完成位): 表示输入/输出操作已完成，这对于确认操作成功至关重要。
* LOK (锁定状态位): 指示设备是否处于锁定状态，这对于控制访问设备非常重要。
* REM (远程状态位): 表示设备是否处于远程控制状态。
* CIC (控制器占用状态位): 指示当前设备是否为控制器，这对于设备之间的协调至关重要。
* ATN (注意信号位): 表示注意信号是否被断言，这在设备通信中是关键的。
* TACS (讲话者状态位) 和 LACS (听话者状态位): 用于确认哪个设备在进行数据传输。
* DTAS (设备触发状态位) 和 DCAS (设备清除状态位): 用于控制和状态管理。

### 异常状态字-iberr

为了在每次 NI-488.2 调用之后检查是否出现错误，可以使用 Ibsta状态字 中的 ERR 位进行判定是否发生了异常   

```cpp
if (ThreadIbsta() & ERR){
    printf("GPIB error encountered");
}
```

虽然通过`(ThreadIbsta() & ERR)`确定通信异常，但是需要定位到具体异常原因时就应该使用`iberr`状态字     

| **缩写** | **值** | **含义**                    |
|----------|--------|-----------------------------|
| **EDVR** | 0      | 系统错误                     |
| **ECIC** | 1      | 函数要求 GPIB 接口为 CIC    |
| **ENOL** | 2      | GPIB 上没有监听器           |
| **EADR** | 3      | GPIB 接口地址不正确         |
| **EARG** | 4      | 函数调用参数无效             |
| **ESAC** | 5      | GPIB 接口不是所需的系统控制器 |
| **EABO** | 6      | 输入/输出操作被中止（超时） |
| **ENEB** | 7      | 不存在的 GPIB 接口           |
| **EDMA** | 8      | DMA 错误                     |
| **EOIP** | 10     | 异步 I/O 正在进行中          |
| **ECAP** | 11     | 无法进行该操作               |
| **EFSO** | 12     | 文件系统错误                 |
| **EBUS** | 14     | GPIB 总线错误                |
| **ESRQ** | 16     | SRQ 卡在开启状态             |
| **ETAB** | 20     | 表格问题                     |
| **ELCK** | 21     | 接口被锁定                   |
| **EARM** | 22     | ibnotify 回调未能重新准备     |
| **EHDL** | 23     | 输入句柄无效                 |
| **EWIP** | 26     | 指定输入句柄正在等待中        | 
| **ERST** | 27     | 由于接口重置，事件通知被取消  |
| **EPWR** | 28     | 接口失去电源                 |

### IO字符计数-Ibcnt  

`Ibcnt`是计数状态字，它包含关于最近一次 I/O 操作中通过 GPIB 传输的字节数量的信息。
计数函数在每次读取、写入或命令函数后进行更新。此外，在某些错误情况下，Ibcnt 也会在特定的 488.2 风格函数之后更新。
如果读取的数据包含 ASCII 字符，可以使用 Ibcnt 来 NULL 终止字符串，并将其视为其他 ASCII 字符串。例如，可以使用 printf 将结果打印到屏幕： 

> 通过 Ibcnt状态字优化缓冲区读取的有效性

缓冲区很大，而读取的文本输入却很少，如何进行优化？请使用Ibcnt状态字   

```cpp
// 字符串数字，可以存储20个字符,加上一个 NULL 字符 '\0'，用来标识字符串的结束
char rdbuf[21];

/*
* ibrd  是一个用于从 GPIB 设备读取数据的函数。
* ud    是一个设备句柄，代表要读取数据的 GPIB 设备。
* rdbuf 是指向读取缓冲区的指针，数据将被存储在这里。
* 20    是要读取的字节数，这里表示最多读取 20 个字节到 rdbuf 中。
*/
ibrd (ud, rdbuf, 20);

if (!(Ibsta() & ERR)){
    /* - Ibcnt() 函数返回最近一次 I/O 操作成功读取的字节数。
    在本例中，它指示从 GPIB 设备实际读取到的数据字节量。
    例如，当 Ibcnt() 返回 15 时，执行 rdbuf[15] = '\0' 
    将在该位置插入 NULL 字符，标志着字符串的结束，确保后续的字符串处理操作能够正确识别读取的数据范围。
    */
    rdbuf[Ibcnt()] = '\0';

    printf ("Read in string: %s\n", rdbuf);
} else {
    // GPIB Error encountered!
}
```


## 轮询查询  
*文档中搜索：Parallel Polling with Traditional NI-488.2 Calls*  


## 直接访问 ni4882.dll 导出函数(C语言)   
*文档中搜索：Directly Accessing the ni4882.dll Exports in C*
