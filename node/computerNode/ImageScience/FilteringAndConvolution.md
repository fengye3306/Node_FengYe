# 滤波与卷积

## **预备知识**

* *滤波器（filter）* **本质就是图像学算法**，但并不是所有图像学算法都叫*filter*，滤波器通常指的是与卷积操作相关的算法。  
* *卷积（Convolution）* 卷积是一种数学运算，本质在于**函数（或矩阵）与另一个函数进行组合来生成新的函数，从而提取输入数据的某种特征。**   
* *卷积核（Convolution Kernel）* 如果有人提起*卷积核*，其实他就是在说*滤波器*，也就是说他在说一种基于卷积的图像学算法。这种算法通常可以用数组来可视化的表达(如下图)。  

![卷积核](./image/FilteringAndConvolution/01.png ':size=WIDTHxHEIGHT')

* *卷积核的锚点* （如上图）可以看见每个核都有一个点的值加粗显示，这个点就被称为"核的锚点"。 **这种锚点定义了核与图像的对齐关系**。

* *线性核、非线性核*  
    线性操作是指满足**叠加性（加法封闭性）和齐次性（数乘封闭性）**两个性质的操作。这意味着，线性操作在数学上可以用**线性方程来描述**。核通常为*线性核*，对于非线性核例如阈值化，以阈值进行分割产出前景与背景就是典型的非线性。

### 边界外推和边界处理

OpenCV对于卷积产生的边界问题时，给出的答案是：*边界外推*，即添加虚幻边界，使得这个虚幻边界用于卷积问题。      

```cpp
void cv::copyMakeBorder(
    cv::InputArray src,       // 源图像
    cv::OutputArray dst,      // 输出图像
    int top,                  // 上边缘填充尺寸
    int bottom,               // 下边缘填充尺寸
    int left,                 // 左边缘填充尺寸
    int right,                // 右边缘填充尺寸
    int borderType,           // 填充方式
    const cv::Scalar& value = cv::Scalar() // 常数填充值（用于某些填充方式）
);
```

> 填充方式与分析

1. cv::BORDER_CONSTANT    
    **描述：**用指定的常数值对边界进行填充。    
    **应用场景：**需要在图像周围添加固定颜色边框时使用，例如对图像进行背景色扩展。    
    **优点：**可以明确控制填充区域的颜色。    
    **缺点：**容易导致图像边缘与填充区域之间产生明显的过渡。    

2. cv::BORDER_REPLICATE  
    **描述：**复制边缘像素到扩展区域。  
    **应用场景：**用于卷积运算时需要保留边缘信息，避免边缘失真。  
    **优点：**能保持图像边缘的纹理特征，不引入新的颜色。  
    **缺点：**在边缘产生拉伸效果，导致边缘特征重复。  

3. cv::BORDER_REFLECT  
    **描述：**对称反射填充，不包含边缘像素，即边缘内的像素反射填充。  
    **应用场景：**需要边缘特征的平滑延续，适合图像卷积和滤波处理。  
    **优点：**保持了边缘的连续性，适合梯度计算。  
    **缺点：**不适用于所有图像，某些情况下会产生对称性伪影。  

4. cv::BORDER_WRAP  
    **描述：**环绕填充，使用图像的另一边的像素填充。  
    **应用场景：**用于需要周期性重复特性的图像处理。  
    **优点：**可以保持图像的周期性特征。  
    **缺点：**不常用，且引入不自然的边缘效果。  

5. cv::BORDER_REFLECT_101 或 cv::BORDER_DEFAULT  
    **描述：**对称反射填充，包含边缘像素（即中间对称反射）。  
    **应用场景：**同 cv::BORDER_REFLECT，适合图像卷积和滤波。  
    **优点：**较好的边缘平滑过渡。  
    **缺点：**与 cv::BORDER_REFLECT 相比，差异在于包含边缘像素。  

6. cv::BORDER_TRANSPARENT  
    **描述：**透明填充（通常为不常用的值）。  
    **应用场景：**一般没有实际意义的填充方式，在 OpenCV 中较少使用。  
    **优点：**无。  
    **缺点：**由于透明度的概念在许多图像处理中无效，此填充方式的使用受限。  

7. cv::BORDER_ISOLATED  
    **描述：**处理图像外部的边缘时忽略（不应用填充）。   
    **应用场景：**在某些需要特殊处理的场合，比如独立处理图像块时。  
    **优点：**对图像本身不做边界改变，适合独立块处理。  
    **缺点：**不改变边界，因此不适合需要扩展边界的操作。  



## **阈值化操作**

阈值化是*非线性核*，其对`1*1`大小的核进行卷积处理，**阈值化操作本质在于锚点根据相较于阈值的高低做出相应处理**。     
计算机视觉领域，很多方法都可以解释为一系列卷积运算，最后一次操作通常是阈值化处理     

```cpp
double cv::threshold( 
    InputArray _src,        // 输入矩阵
    OutputArray _dst,       // 输出矩阵
    double thresh,          // 阈值
    double maxval,          // 阈值
    int type                // 阈值化卷积核接口调用枚举标志
)
```

> OpenCV阈值化卷积核接口调用枚举标志 参数标识

```
/** Threshold types */
enum
{
    /** 
    描述：将图像中的像素值与阈值进行比较，如果像素值大于阈值，则设置为 maxval，否则设置为 0。   
    效果：得到一个二值图像。 
    */
    CV_THRESH_BINARY      =0,  
        /**< value = value > threshold ? max_value : 0       */


    /** 
    描述：与 THRESH_BINARY 相反。如果像素值大于阈值，则设置为 0，否则设置为 maxval。     
    效果：得到一个反转的二值图像。
    */
    CV_THRESH_BINARY_INV  =1,  
        /**< value = value > threshold ? 0 : max_value       */

    /** 
    描述：将像素值与阈值进行比较。如果像素值大于阈值，则将其截断为阈值（即设置为阈值），否则不变。      
    效果：像素值高于阈值的部分被截断到阈值。  
    */
    CV_THRESH_TRUNC       =2,  
        /**< value = value > threshold ? threshold : value   */

    /** 
    描述：如果像素值大于阈值，则保持原值；否则将其设置为 0。      
    效果：像素值低于阈值的部分被置为 0，其他部分保持不变。  
    */
    CV_THRESH_TOZERO      =3,  
        /**< value = value > threshold ? value : 0           */

    /** 
    描述：与 THRESH_TOZERO 相反。如果像素值大于阈值，则保持原值；否则将其设置为 maxval。     
    效果：像素值低于阈值的部分被设置为 maxval，其他部分保持不变。
    */
    CV_THRESH_TOZERO_INV  =4,  
        /**< value = value > threshold ? 0 : value           */

    /** 
    描述：掩码  
    效果：其实你不用关注这个枚举值，这是OpenCV在源码中用于分割枚举阈值的 掩码位
        在源码中OpenCV通过 type &= THRESH_MASK;  相当于 0000 1111 & 0000 0111 = 0000 0111
        用于筛选和提取阈值处理方式的标志位。由于阈值处理方式的标志位在 type 的低三位中，
        所以掩码只需要保留这三位的信息。
        其他的位（如自动阈值计算方法的标志位）会被清除，从而只保留与阈值处理方式相关的标志位。
    */
    CV_THRESH_MASK        =7,

    /** 
    描述：使用 OTSU 方法自动确定阈值。这个方法在图像中自动找到最佳阈值来分割前景和背景。   
    效果：自动选择阈值进行二值化处理。 
    */
    CV_THRESH_OTSU        =8, 
        /**< use Otsu algorithm to choose the optimal threshold value;
                               combine the flag with one of the above CV_THRESH_* values */
    /** 
    描述：使用 TRIANGLE 方法自动确定阈值。这个方法也是一种自动阈值选择算法，基于直方图。  
    效果：自动选择阈值进行二值化处理。
    */                            
    CV_THRESH_TRIANGLE    =16  
        /**< use Triangle algorithm to choose the optimal threshold value;
                 combine the flag with one of the above  CV_THRESH_* values, but not
                 with CV_THRESH_OTSU */
};
```

### Otsu算法

*Otsu命名来自一位日本学者，大津展之（Nobuyuki Otsu）*   
*Otsu 算法 是一种用于图像分割的阈值选择方法，其目的是自动确定一个阈值，将图像划分为前景和背景两部分。该方法通过最大化类间方差来找到最佳阈值，使得前景和背景之间的差异最大化。*       

Otsu 算法的本质是通过找到一个阈值，使得图像被分为前景和背景两部分后，这两部分的**差异最大**，即“前景和背景的区分度”最高。
**差异最大**的本质是选择一个合适的阈值来最大化前景和背景之间的*类间方差*。     

[类间方差数学解析](/node/math/Statistics/Between_Class_Variance.md)  

在讨论 Otsu 算法时，单个峰值直方图通常被认为是其最友好的情况。  
Otsu 算法的设计初衷就是为了**在单峰直方图中找到一个最佳的全局阈值**，以便有效地将前景与背景分开。   
单个峰值直方图表示图像中像素强度的分布相对集中，通常只有一个主要的亮度值。这种情况下，前景和背景的像素强度差异较大，便于通过一个阈值进行分割。   

> Otsu算法使用劣势  

* **直方图单峰友好，多峰抓瞎**       

与单峰直方图不同，多峰直方图包含多个峰值，通常表示图像中存在多个不同的对象或区域。在这种情况下，Otsu 算法会面临挑战，因为它试图找到一个全局阈值来分割图像，但多个峰值导致算法无法确定一个理想的阈值，从而导致分割不准确。   

* **噪声敏感**   
Otsu 算法对噪声比较敏感。如果图像中有较多的噪声或复杂的背景，算法的效果会受到影响。

* **非均匀光照**  
在光照不均的情况下，Otsu 算法会由于整体亮度变化而无法准确地进行分割。  

### 自适应阈值

自适应阈值是一种用于图像分割的技术，它在**处理光照不均的图像**时特别有用。    
与 Otsu 算法不同，自适应阈值根据图像的不同区域动态调整阈值，从而在复杂光照条件下也能获得较好的分割效果。    

算法执行步骤：
1. 选择局部区域    
    图像被分割成多个小的局部区域,**区域大小可定制化**。
2. 计算局部阈值   
    对于每个局部区域，计算一个阈值，**计算算法可定制**。
3. 应用阈值     
    使用局部阈值将图像二值化,**阈值化方式可定制化**。

> OpenCV中自适应阈值实现  

```cpp
cv2.adaptiveThreshold (
    src,                    //输入图像，必须是单通道灰度图。
    maxValue,               //应用于阈值化后的最大值。
    adaptiveMethod,         //自适应阈值方法
    thresholdType,          //阈值化类型
    blockSize,              //用于计算阈值的邻域大小
    C                       //从计算出的阈值中减去的常量，用于微调。
)
```

```OpenCV
/** 自适应阈值方法 */
enum
{
    /**
    描述：使用局部邻域的平均值来计算每个像素的阈值。
        这种方法适用于光照均匀的图像，可以有效消除微小的亮度变化。
    效果：图像被二值化，其中每个像素的阈值是其周围像素的简单平均值减去一个常量 C。
    */
    ADAPTIVE_THRESH_MEAN_C     =0,  
        /**< value = mean of neighborhood - C */
    
    /**
    描述：使用高斯加权后的平均值来计算每个像素的阈值。
        相比于简单平均值，这种方法能更好地处理光照变化，适用于存在较大亮度差异的图像。
    效果：图像被二值化，其中每个像素的阈值是其周围像素的加权平均值减去一个常量 C。高斯核用于加权。
    */
    ADAPTIVE_THRESH_GAUSSIAN_C =1  
        /**< value = weighted sum (Gaussian) of neighborhood - C */
};
```


## **平滑**

*平滑*也被成为*模糊*，是一种简单的图像处理操作。平滑作用通常用于减少*噪声*与*伪影*，在降低图像分辨率时，平滑也是至关重要的。   

> 伪影（artifact）

伪影（artifact）指的是图像中出现的非自然或非预期的视觉元素，它们不是源自真实场景中的对象或特征，而是由于成像系统、图像处理算法、压缩、传输等过程中引入的误差或噪声所造成的。  

1. 压缩伪影：   
    1) 块效应（Blockiness）： 在JPEG等有损压缩格式中，图像被分成多个小块进行处理，可能导致块与块之间的过渡不自然，尤其是在高压缩比时。  
    2) 环效应（Ringing）： 在图像边缘附近出现的环状或振荡伪影，通常由于锐化滤波或压缩算法引起。    

2. 运动伪影：   
    1) 运动模糊（Motion Blur）： 由于相机或物体在曝光期间移动而导致的模糊。  
    2) 鬼影（Ghosting）： 多次曝光或信号干扰导致的重影或叠影。  

3. 光学伪影：   
    1) 色差（Chromatic Aberration）： 由于镜头无法对所有波长的光聚焦到同一点，导致图像边缘出现颜色错位。  
    2) 耀斑（Lens Flare）： 由强光源直接进入镜头引起的光斑或光晕。    
 
4. 重建伪影：     
    1) 条纹（Streaking）： 在CT或MRI等医学图像中，由于数据重建算法或设备误差引起的线状伪影。  
    2) 别名效应（Aliasing）： 当采样率不足以捕捉图像细节时，可能会出现的锯齿状边缘或条纹。  

> OpenCV，指定边缘像素平滑方式（borderType）

OpenCV对于不同平滑算法有不同的函数接口实现，接口中src，dst分别代表源图像与目标图像，其后是不同的平滑操作所需要的参数。   
其中，共有参数borderType,它用于指定**对于边缘像素的平滑方式**。   

![边缘像素平滑方式](./image/FilteringAndConvolution/02.png ':size=WIDTHxHEIGHT')

```OpenCV

/** OpenCV 平滑方式（borderType） */
enum
{
    /**
    描述：对边缘像素进行复制处理。即使用边缘的像素值填充超出边界的部分。
    效果：边缘部分的平滑效果明显，但可能导致图像拉伸。
    */
    BORDER_REPLICATE = 0,
        /**< value = replicate border pixels */

    /**
    描述：对图像进行镜像处理，镜像轴位于边界处。
    效果：边缘部分的平滑较为自然，适合对称图像。
    */
    BORDER_REFLECT = 1,
        /**< value = reflect border pixels */

    /**
    描述：类似于 BORDER_REFLECT，但不包含边界上的最后一个像素。
    效果：避免了完全对称的图像平滑结果，更适合有一定过渡的图像。
    */
    BORDER_REFLECT_101 = 4,
        /**< value = reflect border pixels without repeating the border pixel */

    /**
    描述：以周期方式填充边缘，即使用图像的另一侧像素填充。
    效果：用于周期性或重复性图像处理。
    */
    BORDER_WRAP = 3,
        /**< value = wrap border pixels */

    /**
    描述：对超出边界的像素进行常量填充。
    效果：可用于需要固定背景颜色的图像处理。
    */
    BORDER_CONSTANT = 2,
        /**< value = fill border with constant value */

    /**
    描述：类似于BORDER_REFLECT，镜像边界，但不包含边界上的最后一个像素。
    效果：更为平滑的边缘处理，适用于特定需求的图像。
    */
    BORDER_REFLECT101 = BORDER_REFLECT_101, 
        /**< value = alias for BORDER_REFLECT_101 */

    /**
    描述：与BORDER_CONSTANT相同，填充超出边界的部分为指定的常量值。
    效果：边界平滑但保持一致的背景，适合无干扰背景图像。
    */
    BORDER_TRANSPARENT = 5,
        /**< value = transparent border */

    /**
    描述：与BORDER_REFLECT_101相同。
    效果：对称边缘处理，避免重复像素。
    */
    BORDER_DEFAULT = BORDER_REFLECT_101, 
        /**< value = alias for BORDER_REFLECT_101 */

    /**
    描述：不会对超出边界的像素进行任何处理。
    效果：边界将直接忽略，适用于不需要考虑边缘影响的情况。
    */
    BORDER_ISOLATED = 16
        /**< value = do not look outside of ROI */
};
```

### 均值滤波器  

均值滤波器算法又名为**简单模糊**。       
由于其卷积核进行均值模涂，故而对正态分布的**高斯噪声治理**有相对较好的治理能力，但是其会**模糊图像中的边缘和细节，降低图像锐度**。  

> 算法本质  

算法本质在于，方框型卷积核在图像上移动，每次移动时用窗口内所有像素的平均值替代卷积核的锚点值。

> 算法优点   

* 平滑噪声：有效去除图像中的高斯噪声，使图像变得更加平滑。     
*它的概率密度函数服从高斯分布（即正态分布）的一类噪声*   

> 算法缺点

* 边缘模糊：均值滤波会模糊图像中的边缘和细节，因为边缘像素的强度会被邻域像素的平均值所平滑，导致图像的锐度下降。  
* 细节丢失：均值滤波在去除噪声的同时，可能会丢失图像中的细节信息，使得图像变得不清晰。 
* 对椒盐噪声的处理效果相对不理想。    
*椒盐噪声也称为脉冲噪声，是图像常见的一种噪声，为随机出现的白点或者黑点*

### 中值滤波器

中值滤波器是一种有效的非线性滤波，极度适用于**去除脉冲噪声**并且在治理的同时可以**保护图像边缘**。    

> 算法本质  

中值滤波器算法本质在于，方框型卷积核在图像上移动，每次移动时用窗口内所有像素的**中值**替代卷积核的锚点值。     

> 算法优点

* 有效去除脉冲噪声：对椒盐噪声等脉冲噪声有很好的去除效果。
* 保留边缘：中值取值为图像中的真值，对于边缘有较好的保留效果。      

> 算法缺陷  

* 不适用于高斯噪声：对高斯噪声的去除效微乎其微。

### 高斯滤波器

**高斯滤波器（Gaussian Filter）是最有用的滤波器之一。**  
高斯滤波器是一种线性平滑滤波器，用于**去除图像中的高频噪声**，同时**保持图像的整体结构**。     
它的平滑效果通过对图像进行加权平均实现，权重由高斯函数或称为正态分布（本质就是距离锚点的远近）决定。   

虽然其对于边缘的保留能力仍然大于均值滤波，但其任然存在**边缘模糊**的问题存在，相较于*双边滤波器*其边缘保留能力较弱。    
 

[高斯分布数学解析](/node/math/Statistics/Gaussian_Distribution.md)  

> 高斯滤波器数学模型  

高斯滤波器的权重矩阵（卷积核）由以下公式定义：

@@
G(x, y) = \frac{1}{2\pi\sigma^2} e^{-\frac{x^2 + y^2}{2\sigma^2}}
@@

其中：
- @G(x, y)@ 是高斯函数值。
- @x@ 和 @y@ 是卷积核中相对于中心的坐标。
- @\sigma@ 是标准差，决定滤波器的宽度。
- @e@ 是自然对数的底（约等于2.71828）。

假设我们有一个大小为 @m \times n@ 的图像 @I@ 和大小为 @k \times k@ 的高斯核 @K@，则卷积操作可以表示为：  

@@
I'(x, y) = \sum_{i=-\lfloor k/2 \rfloor}^{\lfloor k/2 \rfloor} \sum_{j=-\lfloor k/2 \rfloor}^{\lfloor k/2 \rfloor} I(x+i, y+j) \cdot G(i, j)
@@

其中：
- @I'(x, y)@ 是卷积后的图像。
- @I(x+i, y+j)@ 是图像的像素值。
- @G(i, j)@ 是高斯核的值。
- @k@ 是高斯核的大小，通常是奇数以确保有中心。

> 高斯滤波器数学运算实例  

如下I为图像区块真值：    

@@
I = 
\begin{bmatrix}
1 & 2 & 1 \\
0 & 1 & 0 \\
2 & 1 & 2
\end{bmatrix}
@@

我们使用一个 @3 \times 3@ 的高斯核，假设 @\sigma = 1@：   

首先计算高斯核 @G@：   

@@
G = 
\begin{bmatrix}
G(-1, -1) & G(-1, 0) & G(-1, 1) \\
G(0, -1) & G(0, 0) & G(0, 1) \\
G(1, -1) & G(1, 0) & G(1, 1)
\end{bmatrix}
@@

计算每个核的值：   

@@
G(-1, -1) = \frac{1}{2\pi(1)^2} e^{-\frac{(-1)^2 + (-1)^2}{2(1)^2}} = \frac{1}{2\pi} e^{-1}
@@

通过类似的计算，我们可以得到高斯核：  

@@
G \approx 
\begin{bmatrix}
0.0751 & 0.1238 & 0.0751 \\
0.1238 & 0.2042 & 0.1238 \\
0.0751 & 0.1238 & 0.0751
\end{bmatrix}
@@

从这里也能看出高斯核即为符合*高斯分布（Gaussian Distribution）*的卷积核。   
高斯核中的每一单元的含义本质是：**密度**    
核中的*锚点值*被视为高斯分布中的标准值，周边值围绕标准值呈*钟形曲线*规则分布。   

说破天了就是一句话：越靠近标准值（锚点）处，我给予越大的权，其在产出的结果@I'(1, 1) @中所占比重越大。   


对图像进行卷积操作：  

@@
I'(1, 1) = \sum_{i=-1}^{1} \sum_{j=-1}^{1} I(1+i, 1+j) \cdot G(i, j)
@@

计算中心位置的卷积：

@@
I'(1, 1) = 1 \cdot 0.0751 + 2 \cdot 0.1238 + 1 \cdot 0.0751 + 0 \cdot 0.1238 + 1 \cdot 0.2042 + 0 \cdot 0.1238 + 2 \cdot 0.0751 + 1 \cdot 0.1238 + 2 \cdot 0.0751
@@

@@
I'(1, 1) \approx 0.0751 + 0.2476 + 0.0751 + 0 + 0.2042 + 0 + 0.1502 + 0.1238 + 0.1502 \approx 1.0262
@@

通过类似的方法，可以计算其他像素位置的卷积结果，得到卷积后的图像 @I'@。

### 双边滤波器

本质来说，其仍然是基于高斯分布进行数学分析的**非线性核**，*相比于*高斯滤波器*，*双边滤波器*在考虑空间域（距离锚点的远近）的同时也考虑了（与锚点值）像素值的相似度，即相似色彩的像素权值越高*。  
虽然这消耗了更多的计算资源，但是它有**出色的保留图像边缘**性能。       

```cpp
void cv::bilateralFilter(
    InputArray src,                     // 输入图像
    OutputArray dst,                    // 输出图像
    int d,                              // 邻域直径
    double sigmaColor,                  // 色彩空间标准差
    double sigmaSpace,                  // 空间域标准差
    int borderType = BORDER_DEFAULT     // 边界处理方式
);
```

* sigmaColor（色彩标准差）  
    1) 低值：当 sigmaColor 较小时，滤波器对颜色差异较敏感，只会平滑相似颜色的区域。如果你想保持图像的颜色细节，但仍然去除一些噪声，可以选择较小的值（如 10-30）。   
    2) 高值：当 sigmaColor 较大时，滤波器会更宽松地处理颜色差异，导致更多颜色相似的像素被平滑。适合于需要较强颜色平滑的场景，例如在处理颜色噪声或均匀化颜色时。可以选择较大的值（如 50-100）。  
*  sigmaSpace（空间标准差）  
    1) 低值：当 sigmaSpace 较小时，滤波器的影响范围仅限于邻近的像素，平滑效果主要局限于局部区域。适用于保持局部细节的场景。一般设置较小值（如 10-30）。    
    2) 高值：当 sigmaSpace 较大时，滤波器会考虑更远的邻域像素，从而在较大的区域内平滑图像。适合于需要大范围平滑的场景，比如背景平滑。可以选择较大的值（如 50-100）。  

> 双边滤波器数学模型

双边滤波器通过两个高斯函数实现加权：一个是空间域的高斯权重，一个是像素值的相似性权重。

假设我们有一个大小为 @m \times n@ 的图像 @I@，双边滤波器的输出 @I'(x, y)@ 可以表示为：  

@@
I'(x, y) = \frac{1}{W_p} \sum_{i=-\lfloor k/2 \rfloor}^{\lfloor k/2 \rfloor} \sum_{j=-\lfloor k/2 \rfloor}^{\lfloor k/2 \rfloor} I(x+i, y+j) \cdot G_s(i, j) \cdot G_r(I(x+i, y+j) - I(x, y))
@@

其中：
- @I'(x, y)@ 是滤波后的图像。
- @G_s(i, j)@ 是空间域的高斯权重。
- @G_r(I(x+i, y+j) - I(x, y))@ 是像素值相似性的高斯权重。
- @W_p@ 是归一化因子，用于确保权重总和为1。

空间域高斯权重计算如下：

@@
G_s(i, j) = \frac{1}{2\pi\sigma_s^2} e^{-\frac{i^2 + j^2}{2\sigma_s^2}}
@@

像素值相似性的高斯权重计算如下：

@@
G_r(\Delta I) = e^{-\frac{\Delta I^2}{2\sigma_r^2}}
@@

其中：
- @\sigma_s@ 是空间域高斯核的标准差，决定了空间平滑的程度。
- @\sigma_r@ 是像素值相似性的标准差，决定了相似像素的影响范围。

> 双边滤波器数学运算实例

如下I为图像区块真值：

@@
I = 
\begin{bmatrix}
1 & 2 & 1 \\
0 & 1 & 0 \\
2 & 1 & 2
\end{bmatrix}
@@

假设我们使用一个 @3 \times 3@ 的空间高斯核，@\sigma_s = 1@ 和 @\sigma_r = 0.1@：   

首先计算空间高斯核 @G_s@：

@@
G_s = 
\begin{bmatrix}
G_s(-1, -1) & G_s(-1, 0) & G_s(-1, 1) \\
G_s(0, -1) & G_s(0, 0) & G_s(0, 1) \\
G_s(1, -1) & G_s(1, 0) & G_s(1, 1)
\end{bmatrix}
@@

计算每个空间高斯权重值：

@@
G_s(-1, -1) = \frac{1}{2\pi(1)^2} e^{-\frac{(-1)^2 + (-1)^2}{2(1)^2}} = \frac{1}{2\pi} e^{-1}
@@

通过类似的计算，可以得到空间高斯核：

@@
G_s \approx 
\begin{bmatrix}
0.0751 & 0.1238 & 0.0751 \\
0.1238 & 0.2042 & 0.1238 \\
0.0751 & 0.1238 & 0.0751
\end{bmatrix}
@@

计算像素值相似性的高斯权重 @G_r@，以中心点 @(1, 1)@ 为例：

@@
G_r(I(x+i, y+j) - I(x, y)) = e^{-\frac{(I(x+i, y+j) - I(1, 1))^2}{2(0.1)^2}}
@@

例如，对于像素 @(0, 0)@ 和中心像素 @(1, 1)@，有：

@@
G_r(1 - 1) = e^{-\frac{(1 - 1)^2}{2(0.1)^2}} = 1
@@

@@
G_r(2 - 1) = e^{-\frac{(2 - 1)^2}{2(0.1)^2}} = e^{-50}
@@

@@
G_r(0 - 1) = e^{-\frac{(0 - 1)^2}{2(0.1)^2}} = e^{-50}
@@

将空间高斯权重和像素值相似性权重结合进行卷积计算：

@@
I'(1, 1) = \frac{1}{W_p} \sum_{i=-1}^{1} \sum_{j=-1}^{1} I(1+i, 1+j) \cdot G_s(i, j) \cdot G_r(I(1+i, 1+j) - I(1, 1))
@@

其中归一化因子 @W_p@ 是权重总和：

@@
W_p = \sum_{i=-1}^{1} \sum_{j=-1}^{1} G_s(i, j) \cdot G_r(I(1+i, 1+j) - I(1, 1))
@@

通过这种方法，双边滤波器能够在去除噪声的同时保留更多的边缘信息和细节。


## **导数和梯度**    

在图像处理中，导数和梯度被用于边缘检测、特征提取。

### 索贝尔导数

索贝尔导数的本质是基于导数的思想，通过对锚点（中心像素）周围的像素值进行加权差分计算，来估计图像在某一方向上的变化率（梯度）。  

```cpp
void Sobel(
    InputArray src,         //输入图像
    OutputArray dst,        //输出图像
    int ddepth,             //输出图像的深度。常见的值为 CV_16S、CV_32F 或 CV_64F。

    /**
    dx 和 dy：分别指定 x 方向和 y 方向的导数阶数
    dx=1, dy=0 计算 x 方向的一阶导数，
    dx=0, dy=1 计算 y 方向的一阶导数，
    dx=2, dy=0 计算 x 方向的二阶导数。
    */
    int dx,                 
    int dy, 

    int ksize=3,                    // Sobel 核的大小，必须为 1、3、5、7
    double scale=1,                 // 可选的缩放因子，用于缩放计算结果。
    double delta=0,                 // 可选的增量值，加到计算结果上
    int borderType=BORDER_DEFAULT   // 边界模式，决定如何处理图像边界。
    );
```

水平梯度卷积核：

@@
G_x =
\begin{bmatrix}
-1 & 0 & 1 \\
-2 & 0 & 2 \\
-1 & 0 & 1
\end{bmatrix}
@@

垂直梯度卷积核：

@@
G_y =
\begin{bmatrix}
-1 & -2 & -1 \\
0 & 0 & 0 \\
1 & 2 & 1
\end{bmatrix}
@@

梯度的强度可以通过以下公式计算：

@@
G = \sqrt{G_x^2 + G_y^2}
@@



### Scharr滤波器

Scharr滤波器由Sobel滤波器优化而来，其本质任然是使用差分思想进行边缘提取。   
具体而言，Scharr滤波器通过对卷积核中的权重进行优化，使得卷积核对图像局部的灰度变化更敏感，同时在梯度方向上获得更精确的响应。   

**梯度的“敏感度”**  
想象一下，我们在平坦的地面上走路，突然前面有个小坡度。如果我们只用一把普通的尺子去测量这个坡度的高度变化，我们可能只能粗略地知道“哦，前面有坡度”。但是，如果我们用一把更精细的尺子去测量，我们不仅可以知道有坡度，还能更精确地测量坡度的陡峭程度。   
在图像处理中，“梯度”就像是这个“坡度”，而Sobel和Scharr滤波器就像那两把不同的尺子。Sobel滤波器是一把普通的尺子，而Scharr滤波器是一把更精细的尺子，它对坡度（图像中的边缘）更加敏感，也就是能更好地检测到图像中的细节和变化。    

在频域中，图像的高频分量对应于细节和边缘。Sobel核在设计时对这些高频分量的响应不均匀，尤其是在斜对角方向上，容易产生较大的误差。Scharr核通过调整卷积核的权重，优化了频谱响应，使其在所有方向上更加均匀。具体来说，Scharr核在设计时，**考虑了各个方向上的频率响应**，通过数学分析确定了如何调整权重，以在所有方向上都更好地保留高频信息。


### 拉普拉斯变换

拉普拉斯变换通常与高斯滤波器结合使用，形成**拉普拉斯-高斯（Laplacian of Gaussian, LoG）**滤波器，以减少噪声干扰。拉普拉斯算子的标准形式为：  
这个卷积核通过计算像素的二阶导数来确定图像中的边缘。**拉普拉斯算子对噪声非常敏感**，因此在实际应用中通常会结合高斯平滑来降低噪声的影响。  


@@
\nabla^2 f = \frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y^2}
@@

离散形式的拉普拉斯算子可以表示为一个 @3 \times 3@ 的卷积核：

@@
L =
\begin{bmatrix}
0 & 1 & 0 \\
1 & -4 & 1 \\
0 & 1 & 0
\end{bmatrix}
@@

## **图像形态学**

图像形态学就像是图像的“形状学”。我们把图像当成一张很大很大的网格，每个小格子里都有一个数字，表示这个地方的颜色或亮度。图像形态学主要用来改变和分析图像中的形状，比如把形状变大、变小、填补空洞或找到边缘。   

举个例子，想象你在一张纸上画了一个大大的不规则形状，图像形态学的操作就像是拿着橡皮擦或者放大镜，对这个形状进行操作：可以让它的边界更平滑、更规则，或者把它周围的空隙填满。   

### 膨胀和腐蚀

> 膨胀和腐蚀核卷积核运算本质  



### 通用形态学函数

### 开操作和闭操作

### 形态学梯度

### 顶帽和黑帽

### 自定义核

## **用任意线性滤波器做卷积**

### 用cv::filter2D进行卷积

### 通过cv::sepFilter2D使用可分核

### 生成卷积核

## **总结**

