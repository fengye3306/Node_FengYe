# 滤波与卷积

## **预备知识**

* *滤波器（filter）* **本质就是图像学算法**，但并不是所有图像学算法都叫*filter*，滤波器通常指的是与卷积操作相关的算法。  
* *卷积（Convolution）* 卷积是一种数学运算，本质在于**函数（或矩阵）与另一个函数进行组合来生成新的函数，从而提取输入数据的某种特征。**   
* *卷积核（Convolution Kernel）* 如果有人提起*卷积核*，其实他就是在说*滤波器*，也就是说他在说一种基于卷积的图像学算法。这种算法通常可以用数组来可视化的表达(如下图)。  

![卷积核](./image/FilteringAndConvolution/01.png ':size=WIDTHxHEIGHT')

* *卷积核的锚点* （如上图）可以看见每个核都有一个点的值加粗显示，这个点就被称为"核的锚点"。 **这种锚点定义了核与图像的对齐关系**。

* *线性核、非线性核*  
    线性操作是指满足**叠加性（加法封闭性）和齐次性（数乘封闭性）**两个性质的操作。这意味着，线性操作在数学上可以用**线性方程来描述**。核通常为*线性核*，对于非线性核例如阈值化，以阈值进行分割产出前景与背景就是典型的非线性。

### 边界外推和边界处理

OpenCV对于卷积产生的边界问题时，给出的答案是：*边界外推*，即添加虚幻边界，使得这个虚幻边界用于卷积问题。      

```cpp
void cv::copyMakeBorder(
    cv::InputArray src,       // 源图像
    cv::OutputArray dst,      // 输出图像
    int top,                  // 上边缘填充尺寸
    int bottom,               // 下边缘填充尺寸
    int left,                 // 左边缘填充尺寸
    int right,                // 右边缘填充尺寸
    int borderType,           // 填充方式
    const cv::Scalar& value = cv::Scalar() // 常数填充值（用于某些填充方式）
);
```

> 填充方式与分析

1. cv::BORDER_CONSTANT    
    **描述：**用指定的常数值对边界进行填充。    
    **应用场景：**需要在图像周围添加固定颜色边框时使用，例如对图像进行背景色扩展。    
    **优点：**可以明确控制填充区域的颜色。    
    **缺点：**容易导致图像边缘与填充区域之间产生明显的过渡。    

2. cv::BORDER_REPLICATE  
    **描述：**复制边缘像素到扩展区域。  
    **应用场景：**用于卷积运算时需要保留边缘信息，避免边缘失真。  
    **优点：**能保持图像边缘的纹理特征，不引入新的颜色。  
    **缺点：**在边缘产生拉伸效果，导致边缘特征重复。  

3. cv::BORDER_REFLECT  
    **描述：**对称反射填充，不包含边缘像素，即边缘内的像素反射填充。  
    **应用场景：**需要边缘特征的平滑延续，适合图像卷积和滤波处理。  
    **优点：**保持了边缘的连续性，适合梯度计算。  
    **缺点：**不适用于所有图像，某些情况下会产生对称性伪影。  

4. cv::BORDER_WRAP  
    **描述：**环绕填充，使用图像的另一边的像素填充。  
    **应用场景：**用于需要周期性重复特性的图像处理。  
    **优点：**可以保持图像的周期性特征。  
    **缺点：**不常用，且引入不自然的边缘效果。  

5. cv::BORDER_REFLECT_101 或 cv::BORDER_DEFAULT  
    **描述：**对称反射填充，包含边缘像素（即中间对称反射）。  
    **应用场景：**同 cv::BORDER_REFLECT，适合图像卷积和滤波。  
    **优点：**较好的边缘平滑过渡。  
    **缺点：**与 cv::BORDER_REFLECT 相比，差异在于包含边缘像素。  

6. cv::BORDER_TRANSPARENT  
    **描述：**透明填充（通常为不常用的值）。  
    **应用场景：**一般没有实际意义的填充方式，在 OpenCV 中较少使用。  
    **优点：**无。  
    **缺点：**由于透明度的概念在许多图像处理中无效，此填充方式的使用受限。  

7. cv::BORDER_ISOLATED  
    **描述：**处理图像外部的边缘时忽略（不应用填充）。   
    **应用场景：**在某些需要特殊处理的场合，比如独立处理图像块时。  
    **优点：**对图像本身不做边界改变，适合独立块处理。  
    **缺点：**不改变边界，因此不适合需要扩展边界的操作。  



## **阈值化操作**

阈值化是*非线性核*，其对`1*1`大小的核进行卷积处理，**阈值化操作本质在于锚点根据相较于阈值的高低做出相应处理**。     
计算机视觉领域，很多方法都可以解释为一系列卷积运算，最后一次操作通常是阈值化处理     

```cpp
double cv::threshold( 
    InputArray _src,        // 输入矩阵
    OutputArray _dst,       // 输出矩阵
    double thresh,          // 阈值
    double maxval,          // 阈值
    int type                // 阈值化卷积核接口调用枚举标志
)
```

> OpenCV阈值化卷积核接口调用枚举标志 参数标识

```
/** Threshold types */
enum
{
    /** 
    描述：将图像中的像素值与阈值进行比较，如果像素值大于阈值，则设置为 maxval，否则设置为 0。   
    效果：得到一个二值图像。 
    */
    CV_THRESH_BINARY      =0,  
        /**< value = value > threshold ? max_value : 0       */


    /** 
    描述：与 THRESH_BINARY 相反。如果像素值大于阈值，则设置为 0，否则设置为 maxval。     
    效果：得到一个反转的二值图像。
    */
    CV_THRESH_BINARY_INV  =1,  
        /**< value = value > threshold ? 0 : max_value       */

    /** 
    描述：将像素值与阈值进行比较。如果像素值大于阈值，则将其截断为阈值（即设置为阈值），否则不变。      
    效果：像素值高于阈值的部分被截断到阈值。  
    */
    CV_THRESH_TRUNC       =2,  
        /**< value = value > threshold ? threshold : value   */

    /** 
    描述：如果像素值大于阈值，则保持原值；否则将其设置为 0。      
    效果：像素值低于阈值的部分被置为 0，其他部分保持不变。  
    */
    CV_THRESH_TOZERO      =3,  
        /**< value = value > threshold ? value : 0           */

    /** 
    描述：与 THRESH_TOZERO 相反。如果像素值大于阈值，则保持原值；否则将其设置为 maxval。     
    效果：像素值低于阈值的部分被设置为 maxval，其他部分保持不变。
    */
    CV_THRESH_TOZERO_INV  =4,  
        /**< value = value > threshold ? 0 : value           */

    /** 
    描述：掩码  
    效果：其实你不用关注这个枚举值，这是OpenCV在源码中用于分割枚举阈值的 掩码位
        在源码中OpenCV通过 type &= THRESH_MASK;  相当于 0000 1111 & 0000 0111 = 0000 0111
        用于筛选和提取阈值处理方式的标志位。由于阈值处理方式的标志位在 type 的低三位中，
        所以掩码只需要保留这三位的信息。
        其他的位（如自动阈值计算方法的标志位）会被清除，从而只保留与阈值处理方式相关的标志位。
    */
    CV_THRESH_MASK        =7,

    /** 
    描述：使用 OTSU 方法自动确定阈值。这个方法在图像中自动找到最佳阈值来分割前景和背景。   
    效果：自动选择阈值进行二值化处理。 
    */
    CV_THRESH_OTSU        =8, 
        /**< use Otsu algorithm to choose the optimal threshold value;
                               combine the flag with one of the above CV_THRESH_* values */
    /** 
    描述：使用 TRIANGLE 方法自动确定阈值。这个方法也是一种自动阈值选择算法，基于直方图。  
    效果：自动选择阈值进行二值化处理。
    */                            
    CV_THRESH_TRIANGLE    =16  
        /**< use Triangle algorithm to choose the optimal threshold value;
                 combine the flag with one of the above  CV_THRESH_* values, but not
                 with CV_THRESH_OTSU */
};
```

### Otsu算法

*Otsu命名来自一位日本学者，大津展之（Nobuyuki Otsu）*   
*Otsu 算法 是一种用于图像分割的阈值选择方法，其目的是自动确定一个阈值，将图像划分为前景和背景两部分。该方法通过最大化类间方差来找到最佳阈值，使得前景和背景之间的差异最大化。*       

Otsu 算法的本质是通过找到一个阈值，使得图像被分为前景和背景两部分后，这两部分的**差异最大**，即“前景和背景的区分度”最高。
**差异最大**的本质是选择一个合适的阈值来最大化前景和背景之间的*类间方差*。     

[类间方差数学解析](/node/math/Statistics/Between_Class_Variance.md)  

在讨论 Otsu 算法时，单个峰值直方图通常被认为是其最友好的情况。  
Otsu 算法的设计初衷就是为了**在单峰直方图中找到一个最佳的全局阈值**，以便有效地将前景与背景分开。   
单个峰值直方图表示图像中像素强度的分布相对集中，通常只有一个主要的亮度值。这种情况下，前景和背景的像素强度差异较大，便于通过一个阈值进行分割。   

> Otsu算法使用劣势  

* **直方图单峰友好，多峰抓瞎**       

与单峰直方图不同，多峰直方图包含多个峰值，通常表示图像中存在多个不同的对象或区域。在这种情况下，Otsu 算法会面临挑战，因为它试图找到一个全局阈值来分割图像，但多个峰值导致算法无法确定一个理想的阈值，从而导致分割不准确。   

* **噪声敏感**   
Otsu 算法对噪声比较敏感。如果图像中有较多的噪声或复杂的背景，算法的效果会受到影响。

* **非均匀光照**  
在光照不均的情况下，Otsu 算法会由于整体亮度变化而无法准确地进行分割。  

### 自适应阈值

自适应阈值是一种用于图像分割的技术，它在**处理光照不均的图像**时特别有用。    
与 Otsu 算法不同，自适应阈值根据图像的不同区域动态调整阈值，从而在复杂光照条件下也能获得较好的分割效果。    

算法执行步骤：
1. 选择局部区域    
    图像被分割成多个小的局部区域,**区域大小可定制化**。
2. 计算局部阈值   
    对于每个局部区域，计算一个阈值，**计算算法可定制**。
3. 应用阈值     
    使用局部阈值将图像二值化,**阈值化方式可定制化**。

> OpenCV中自适应阈值实现  

```cpp
cv2.adaptiveThreshold (
    src,                    //输入图像，必须是单通道灰度图。
    maxValue,               //应用于阈值化后的最大值。
    adaptiveMethod,         //自适应阈值方法
    thresholdType,          //阈值化类型
    blockSize,              //用于计算阈值的邻域大小
    C                       //从计算出的阈值中减去的常量，用于微调。
)
```

```OpenCV
/** 自适应阈值方法 */
enum
{
    /**
    描述：使用局部邻域的平均值来计算每个像素的阈值。
        这种方法适用于光照均匀的图像，可以有效消除微小的亮度变化。
    效果：图像被二值化，其中每个像素的阈值是其周围像素的简单平均值减去一个常量 C。
    */
    ADAPTIVE_THRESH_MEAN_C     =0,  
        /**< value = mean of neighborhood - C */
    
    /**
    描述：使用高斯加权后的平均值来计算每个像素的阈值。
        相比于简单平均值，这种方法能更好地处理光照变化，适用于存在较大亮度差异的图像。
    效果：图像被二值化，其中每个像素的阈值是其周围像素的加权平均值减去一个常量 C。高斯核用于加权。
    */
    ADAPTIVE_THRESH_GAUSSIAN_C =1  
        /**< value = weighted sum (Gaussian) of neighborhood - C */
};
```


## **平滑**

*平滑*也被成为*模糊*，是一种简单的图像处理操作。平滑作用通常用于减少*噪声*与*伪影*，在降低图像分辨率时，平滑也是至关重要的。   

> 伪影（artifact）

伪影（artifact）指的是图像中出现的非自然或非预期的视觉元素，它们不是源自真实场景中的对象或特征，而是由于成像系统、图像处理算法、压缩、传输等过程中引入的误差或噪声所造成的。  

1. 压缩伪影：   
    1) 块效应（Blockiness）： 在JPEG等有损压缩格式中，图像被分成多个小块进行处理，可能导致块与块之间的过渡不自然，尤其是在高压缩比时。
    2) 环效应（Ringing）： 在图像边缘附近出现的环状或振荡伪影，通常由于锐化滤波或压缩算法引起。  

2. 运动伪影：   
    1) 运动模糊（Motion Blur）： 由于相机或物体在曝光期间移动而导致的模糊。
    2) 鬼影（Ghosting）： 多次曝光或信号干扰导致的重影或叠影。

3. 光学伪影：   
    1) 色差（Chromatic Aberration）： 由于镜头无法对所有波长的光聚焦到同一点，导致图像边缘出现颜色错位。
    2) 耀斑（Lens Flare）： 由强光源直接进入镜头引起的光斑或光晕。  

4. 重建伪影：   
    1) 条纹（Streaking）： 在CT或MRI等医学图像中，由于数据重建算法或设备误差引起的线状伪影。
    2) 别名效应（Aliasing）： 当采样率不足以捕捉图像细节时，可能会出现的锯齿状边缘或条纹。

> OpenCV，指定边缘像素平滑方式（borderType）

OpenCV对于不同平滑算法有不同的函数接口实现，接口中src，dst分别代表源图像与目标图像，其后是不同的平滑操作所需要的参数。   
其中，共有参数borderType,它用于指定**对于边缘像素的平滑方式**。   

![边缘像素平滑方式](./image/FilteringAndConvolution/02.png ':size=WIDTHxHEIGHT')

/** OpenCV 平滑方式（borderType） */
enum
{
    /**
    描述：对边缘像素进行复制处理。即使用边缘的像素值填充超出边界的部分。
    效果：边缘部分的平滑效果明显，但可能导致图像拉伸。
    */
    BORDER_REPLICATE = 0,
        /**< value = replicate border pixels */

    /**
    描述：对图像进行镜像处理，镜像轴位于边界处。
    效果：边缘部分的平滑较为自然，适合对称图像。
    */
    BORDER_REFLECT = 1,
        /**< value = reflect border pixels */

    /**
    描述：类似于 BORDER_REFLECT，但不包含边界上的最后一个像素。
    效果：避免了完全对称的图像平滑结果，更适合有一定过渡的图像。
    */
    BORDER_REFLECT_101 = 4,
        /**< value = reflect border pixels without repeating the border pixel */

    /**
    描述：以周期方式填充边缘，即使用图像的另一侧像素填充。
    效果：用于周期性或重复性图像处理。
    */
    BORDER_WRAP = 3,
        /**< value = wrap border pixels */

    /**
    描述：对超出边界的像素进行常量填充。
    效果：可用于需要固定背景颜色的图像处理。
    */
    BORDER_CONSTANT = 2,
        /**< value = fill border with constant value */

    /**
    描述：类似于BORDER_REFLECT，镜像边界，但不包含边界上的最后一个像素。
    效果：更为平滑的边缘处理，适用于特定需求的图像。
    */
    BORDER_REFLECT101 = BORDER_REFLECT_101, 
        /**< value = alias for BORDER_REFLECT_101 */

    /**
    描述：与BORDER_CONSTANT相同，填充超出边界的部分为指定的常量值。
    效果：边界平滑但保持一致的背景，适合无干扰背景图像。
    */
    BORDER_TRANSPARENT = 5,
        /**< value = transparent border */

    /**
    描述：与BORDER_REFLECT_101相同。
    效果：对称边缘处理，避免重复像素。
    */
    BORDER_DEFAULT = BORDER_REFLECT_101, 
        /**< value = alias for BORDER_REFLECT_101 */

    /**
    描述：不会对超出边界的像素进行任何处理。
    效果：边界将直接忽略，适用于不需要考虑边缘影响的情况。
    */
    BORDER_ISOLATED = 16
        /**< value = do not look outside of ROI */
};

### 简单模糊和方框型滤波器

### 中值滤波器

### 高斯滤波器

### 双边滤波器

## **导数和梯度**

### 索贝尔导数

### Scharr滤波器

### 拉普拉斯变换

## **图像形态学**

### 膨胀和腐蚀

### 通用形态学函数

### 开操作和闭操作

### 形态学梯度

### 顶帽和黑帽

### 自定义核


## **用任意线性滤波器做卷积**

### 用cv::filter2D进行卷积

### 通过cv::sepFilter2D使用可分核

### 生成卷积核

## **总结**

