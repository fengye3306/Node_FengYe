
### 简单对象模型  
**A Simple Object Model**   


在简单对象模型设计中，对象不直接存放方法的方法与属性，而是存放指向存放对应方法、属性的空间的指针。  

这一设计好处在于设计编译器时比较节约脑细胞，即 `对象大小 == （方法数+属性数）*指针大小`。   
缺点在于多一个查找指针行为会拖慢速度，而且增加存储压力。  

*此设计思想并未在实际产品中被运用，但是它提供了“指向成员的指针”这一思路。*

![简易对象模型](./img/1/1.PNG ':size=WIDTHxHEIGHT')

### 表格驱动对象模型 

**A Table-driven Object Model**  

表格驱动对象模型将一个类的成员分为两类：data member（属性）与member function（方法）。  
并分别为两类成员建立表data member table（属性表）与表member function table（方法表）。   

属性表直接存储属性本体。方法表存放指针，而指针指向存放方法的空间。   

这一结构的优点在于间接性，即，改变类的设计增加删除各类属性都和已有程序中的对象并不产生直接关联。因为对象中只存放了两表的指针，天塌下来看不见，从而节约编译时间。   
缺点就是程序效率被拖的更慢了，对于方法来说，一次调用需要两次寻址。

*此设计并未被实际采用，但是“表”一概念却被用于虚函数的存储架构设计。*

![表格驱动对象模型](./img/1/2.PNG ':size=WIDTHxHEIGHT')


### C++对象模型  

**The C++ Object Model**    

在这个设计模型中，只有非静态属性被存放于对象本体中。其余的，即 静态属性、静态方法、非静态方法都只保存指针给予指向，而对于虚函数来说，其使用表格模型方式进行管理。   


这个方法大抵是保证了空间和存储时间的优化，缺点在于当类的非虚函数成员发生删减时就会发生对象改变从而重新编译。  

> C++对象模型对于虚函数的存储设计  

对于virtual function，C++对象模型使用“表格对象模型”思想对其进行规划。  

对于对象的虚函数的存储结构来说，一个名为virtual table（简称vtbl）的表格其内部保存一系列指向对象的虚函数的指针。而对象添加一个被称为vptr的指针，其只管指向vtbl。    

其中，vptr由 构造函数、析构函数、拷贝构造函数管控。

![c++对象模型](./img/1/3.PNG ':size=WIDTHxHEIGHT')


### 策略性正确的struct

> C中的部分技巧是C++的陷阱

C中存在一个技巧，即在结构体的末尾写上一个单一类型数组，就能获得一个可变长数组。其原理在于C中对于结构体的在内存的存储由声明顺序排列。
分析使用代码。  
malloc函数所做的仅仅是开辟一片指定大小的内存空间并返回内存首地址，`(struct mumble*)`触发类型强制转换而类型发生改变，而实际上这块内存是要比mumble类型要大的，但是不管，就是转。  
strcpy函数所做的仅仅是内存中数据的拷贝，有没有越界它真就不管，就硬拷。在C中结构体于内存中按声明顺序排布与声明时强制取巧分配更大内存的双向加持下，这个行为居然不会产生实际的越界。   

而C对于数组名为首地址 此指针解释之灵活更助长了此一恶行。

*我的评价是：这样写代码的程序员应该被拉去坐牢。*

```C
struct mumble
{
      /* stuff */
      char pc[1];  
};
    
//从文件或标准输入装置中取得一个字符串
//然后为struct 本身和该字符配置足够的内存
 
struct mumble * pmumbl = (struct mumble*)
             malloc(sizeof(struct mumble) + strlen(string) +1);
strcpy(&mumble.pc,string);
```

### 指针的本质

```c++
std::string *str;
int *val;
```

对于如上两个指针，其本质的不同到底是什么呢？大小？不不不，指针永远只占四个字节。所保存的内容？也不对，**任何指针所保存的都是某个内存块的首地址**。   
那么不同类型的指针其最本质的区别到底是什么？  
答案是，**寻址范围**。   

指针与指针最本质的区别就是寻址范围。

气氛都烘托到这了，必须狠狠的继续解答疑惑————为什么我有`void*`指针却不让直接使用？一定要转换类型？    
答案也许是显而易见的，**void*不知道自己要寻址多少距离！**

### 多态的实现原理

> 派生类在内存中存储的本质  

当不显式的在**派生类**构造函数指明父类构造函数时，编译器会隐式的在**派生类**构造函数中补上其基类的默认构造函数。 如此，沿着派生链依次向上绽放基类的构造函数。    

可以知道，一个派生类其占用的内存 大小是固定的，具体大小为`基类所占内存空间+派生类额外大小 = 派生类所占内存空间`。  

当一个指针指向一个对象时，本质的来说，它指向的是此对象内存空间的首地址。这里注意一个概念，即，内存是有首有尾，有前有后的。  
那么对于一个处于面向对象程序设计范式的派生类而言，其在内存中是怎么排布的，可有特定顺序？  
有！在内存中编译器将会沿着派生链去构造对象。  

> 为什么基类指针可以接收一个派生类对象   

*指针与指针区别的本质是什么？*   
答：**指针与指针的区别在于寻址范围不同。**，例如一个自定义类型`class FENGYE`其对象实体占用32字节内存空间，而内置类型int占有4个字节。   
现有`FENGYE *`与`int *`,其两者指针本体大小都为两字节，其保存的内容都为一片内存空间的首地址。实际上，其二者最本质的区别是，对于`FENGYE *`来说，其会寻找自己所保存的内存首地址向后的32个字节空间。`int *`只会寻找4个字节。   

将此问题套用到派生关系，上面小节论述了两个问题————其一是派生类大小 == 基类所占内存空间+派生类的额外大小，其二是在内存空间中，派生类的内存分布根据派生链顺序分布构造。   

一个困扰许久的问题就迎刃而解————为什么基类指针获取派生类对象的时候不能调用派生类的额外成员。 答案就是！找不到！！！基类指针的寻址范围不足以覆盖派生类所占的空间。          
如下图`class B: public A;`  类B派生于类A，且类A位于继承链的顶端。   

![指针寻址](./img/1/4.PNG ':size=WIDTHxHEIGHT')



回忆虚函数实现问题，编译器通过构造vptr从而指向虚表virtual function table，而virtual function table中存放有指针去指向具体的虚函数实现。这就是基类指针保存子类实现，调用有子类重写的虚函数时调用的是子类版本的原因了，当派生类本体在被构建时，`virtual function table`中虚函数的指向指向于子类的最新实现。  

这就是C++对于多态的实现的本质。   


### 为什么指针可以实体不可以？   

更详细的展开一下标题：在使用面向对象多态时，为什么派生类必须绑定于基类指针而非基类实体？  
```c++
A  a1 = new B();   // 值拷贝 会产生切削
A *a2 = new B();   // 址拷贝 分毫不损
```

本质是清晰可见的：即地址拷贝时，类A作为基类必然是吃不下一个派生类类B的。这里的拷贝是有损的，会产生切削的。  
问题再来了，即使a1强行有损的吃下了类B的这片空间，那么a1调用有B类实现的虚函数时调用的是类A版本还是类B版本（多态会不会触发）？   
答案是，多态不会被触发，调用的将会是类A的版本。唉？奇怪，明明按照规则来说即使有损切割，vptr也是存放在基类里的啊？  
其实是编译器的保护规则————它不能容忍一个有损拷贝行为来触发面向对象范式！。   

而对于指针来说，它就是一个纯纯粹粹的表征寻址范围与存储头文件的工具，对于其来说变换寻址范围与对象本体又有何损？   