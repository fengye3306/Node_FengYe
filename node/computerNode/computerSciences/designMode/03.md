
### 抽象工厂模式   


> 架构

![架构](./img/03/01.PNG ':size=WIDTHxHEIGHT')  

* AbstractFactory     
操作产品对象的抽象接口    

* ConcreteFactory   
具体的产品操作    

* AbstractProduct   
某一类产品的抽象接口

* ConcreteProduct()   
定义一个具体的产品对象接口

* Client   
用户,仅仅使用AbstractFactory和AbstractProduct的抽象接口

> 实现   

1. 将工厂作为单例   

2. 创建产品_工厂方法    

创建产品由具体ConcreteFactory完成。换一个视角观测，产品基类与工厂基类也是一个虚对应的关系，符合工厂方法结构。  
可以为产品定义工厂方法，具体的工厂为每个产品重定义该工厂方法以指定产品。    

3. 创建产品_原型模式   

可以不用使得每一个产品系列必须创建一个具体的ConcreteFactory。    
实际上AbstractProduct也可以作为原型模式设计。


4. 定义可扩展的工厂   

给创建对象的操作增加一个参数，此参数指定被创建对象的种类，参数可以是任何附带信息的标识。    



### BUILDER模式   

> 架构

![架构](./img/03/02_BUILDER.PNG ':size=WIDTHxHEIGHT')     

> 实例



### 工厂方法

工厂方法是一个以虚对虚的结构，即方法的提供类和方法的使用类均以接口的形式链接。   
实际上方法的使用类并不知道具体会实例化方法的提供类的结构树中哪一个具体子类。     

由此，将实例化的行为单独抽取出来。   
请看如下的“实例”将会有详细解答。    


> 架构

![架构](./img/03/02_FACTORY_METHOD.PNG ':size=WIDTHxHEIGHT')  

* Product    
定义工厂方法 所创建的对象的接口类    

* ConcreteProduct
是Product的派生类，确实的实现了其接口  

* Creator    
功能的使用者 接口类     

* ConcreteCreator   
单独将Product的创建的决定权抽取出来的接口，派生类ConcreteCreator将实现此接口完成具体的Product子类创建


> 实例   

![架构](./img/03/02_Factory_Method_Example.PNG ':size=WIDTHxHEIGHT')  


* Application   
功能的使用者   

* Document   
功能的提供者    

* CreateDocument()    
接口，用于创建具体的Document派生树子类


Application将具体的Document对象创建延迟到自身的派生类。即**单独将Document的创建的决定权抽取**，由子类通过CreateDocument接口完成。    




### 原型模式


> 架构   

![架构](./img/03/02.PNG ':size=WIDTHxHEIGHT')  

* Prototype    
需要其给与Clone入口的类   

* ConcretePrototype   
具体实现Clone接口，是产品类     

* Client    
用户，指派原型克隆自身而产出新对象。   


> 案例   

* 创建乐谱绘制软件。    

对于高音谱号、低音谱号、八分音符、四分音符、十六分音符......乐符有Graphics基类及种种乐符对应的派生。   
现有一工具类GraphicsTool用于将各个Graphics的派生添加于界面中。   
GraphicsTool属于系统架构，其也应通过实例化Graphics完成功能。    
可以为每一个Graphics的派生创建对应的GraphicsTool派生，但是这将带来类数目的膨胀。   
此时即可通过原型模式完成功能设计，**阻止膨胀的代码结构**。   











