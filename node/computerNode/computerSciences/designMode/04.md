### FACADE（外观）

> 动机

外观模式为降低子系统之间的耦合度，使得子系统间仅仅需要更少的相互依赖。   

![外观模式动机](./img/04/FACADE01.PNG ':size=WIDTHxHEIGHT')  
  
例如一个编译器的子模块实现，此编译器子模块由多个复杂低层类组成。多数用户并不关心语法分析等低层类细节，他们只希望完成一些编译功能。   
提供一个高层接口类为用户屏蔽低层类，但是无需完隐藏那些低层类，对少数懂得低层功能的人仍然可以调用之。

> 适用性  

* **子系统往往因为演化而越发复杂**，会产生越来越多的更小类。   

* 降低系统与客户类之间的依赖，使得**可移植性提高**。   
直接依赖子模块的低层类，如果哪一天类废弃了或是类的接口废弃了，项目的多处可能也会需要跟着修改。   
反之如果依赖于界面类Facade，Facade代表着功能意愿的集合体，就仅仅可以通过简单的改写接口对子模块的低层类调用。

* Facade很适合作为层次结构子系统中，子系统的**入口点**。


> 结构

![外观模式动机](./img/04/FACADE02.PNG ':size=WIDTHxHEIGHT')  


> 实现   


可以把Facade作为抽象的功能集，用不同的子模块来完成其功能，必要时就替换具体的Facade实现。   
例如渲染行为，VTK、太极、OpenGL都可以完成。   


> 代码实例   

代码示例就请看原书此节，此节提到对于一个子模块————多类协调完成从源代码编译到到机器码的子模块，其使用builder模式进行不同硬件平台实现。对于这样的一个子模块的Facade模式封装。   


### FLYWEIGHT享元   
*支持细颗粒度的大量对象，其本质活字应刷术*   
重点在于外部状态与内部状态，内部状态就是活字印刷中的一个又一个字符，外部状态就是活字印刷是在使用中的排列横纵值。          



> 动机

面向对象的文本编辑器通常使用对象表示被嵌入的成分，例如一个文字字符会是一个对象。  
但是即便一个中型大小的文档都会产生成百上千的字符，这内存开销过于高昂了。  

Flywight模式描述如何共享对象，使得细颗粒度的使用他们而无需高昂代价。    




flyweigth关键在于**内部状态**与**外部状态**之间的区别。  
内部状态存储与flyweight之中，包含了独立于flyweight场景的信息。例如下共享池中的每一flyweight其所存储的字符，就是内部状态。   
外部状态是取决于Flyweight的场景，其需要根据场景发生变化因此不可被共享。如下图中源字符知道自己在活字印刷中的字符，但是不知道自己在场景中的坐标，决定坐标的是包裹其的包裹对象。这个就是外部信息了。   
  
![实例](./img/04/FLYWEIGHT01.PNG ':size=WIDTHxHEIGHT')  



> 适用性   

* 一个应用程序使用了大量对象  
* 完全由于适用大量对象造成很大**内存开销**
* 对象大部分状态可被改变为外部状态。  
* 应用程序不依赖于对象标识，例如每个对象都有自己的独立标识，则享元不适用。   


> 结构    

![实例](./img/04/FLYWEIGHT02.PNG ':size=WIDTHxHEIGHT')  



* Flyweight    

描述了一个接口集合，通过此接口集合接收并被作用于外部状态。   

* ConcreteFlyweight 被共享的派生   

对基类的接口进行实现，并且为内部状态增加存储空间。ConcreteFlyweight**必须是可共享的**。其存储的状态也必须是内部的。    

* UnsharedConcreteFlyweight 被共享的派生 

并非所有的Flyweight子类都需要被共享。Flyweight仅仅使得共享成为可能，但是并不强制。   
甚至通常来说ConcreteFlyweight也可作为 UnsharedConcreteFlyweight的子节点，例如在文档结构中的RowGlyph(行图元)   
但是这不是对象组合模式吗？额......

* FlyweightFactory   对象池

创建，管理flyweightFactory对象，用户请求时FlyweightFactory就提供一个已经创建实例或者如果没有对应内部状态的元，就创建一个。   

* Client    

维持一个对flyweight的引用。   
计算或存储一个（多个）flyweight的外部状态。   





