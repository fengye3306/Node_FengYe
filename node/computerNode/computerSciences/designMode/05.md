### CHAIN OF RESPONSIBILITY   

*职责链模式*    

> 意图   

对于一个请求，多个对象都有机会处理请求，将这些对象连成一条链，沿着链子传递请求，直到某对象将其处理。   

类似的，在QT框架中，事件可以被传递，名为WIdget::Click的事件从一某窗口中诞生，当此窗口忽略此事件时，他将此事件向上抛出，直到在某处被消耗，或归于Application。   

> 实例   

*在链上的对象都需要有一致的请求和访问链上后继者的接口。*

如下，通过混入类HelpHandler使得其子类派生链拥有传递HandleHelp的能力。   

![实例](./img/05/RESPONSIBILITY.PNG ':size=WIDTHxHEIGHT')  


> 设计图   

![实例](./img/05/RESPONSIBILITY2.PNG ':size=WIDTHxHEIGHT') 

其实，参考QT的窗口实现即可。   




### 策略模式   

策略模式就像是我们在决定如何去超市一样。我们可以选择步行，骑自行车，开车或乘坐公交。每种出行方式都可以看作是一种策略。      
假设我们现在要编写一个程序，这个程序的功能就是去超市。我们可以定义一个接口（或抽象基类）叫做"GoToSupermarket"，这个接口有一个方法叫做"go"。然后，我们为每种出行方式创建一个类，比如"Walk"，"Bike"，"Car"，"Bus"，这些类都实现（或继承）了"GoToSupermarket"接口，并在"go"方法中实现具体的移动方式。    
这样，当我们需要去超市的时候，我们可以根据实际情况选择最合适的策略对象，把它传给"GoToSupermarket"，然后调用"go"方法。由于多态的特性，实际执行的将是对应策略对象的"go"方法。    
  


### 模板方法模式  

让我们想象一下你正在做一个蛋糕。有一些步骤是所有蛋糕都必须经过的，比如搅拌面粉和糖，然后把它们放进烤箱烤。但是，有一些步骤会根据你要做的蛋糕的种类而变化，比如你可能会在面糊里加入巧克力酱，或者加入柠檬汁。这就是模板方法模式的核心思想，**你有一个基本的步骤框架（也就是模板），并且某些步骤会被子类覆盖以实现特定的行为**。   
而模板方法模式和 NVI（Non-Virtual Interface）（NVI是一种编程技巧，在C++中常见，但并不单独表示为一种设计模式）有着紧密的联系。     
假设你正在经营一家餐厅，你不希望你的厨师直接和客户交流，因为这可能会导致混乱或者误解。相反，你会希望有一个服务员作为中间人，他们了解菜单，理解厨师的意图，并且可以清晰地向客户解释菜单。在这个例子中，服务员就像是 NVI，他们提供了一个非虚接口，所有的交流都必须通过他们。厨师（也就是子类）可以自由地做他们擅长的事情，但是他们不能直接和客户（也就是调用者）交流。  
综上，模板方法模式提供了一个框架，允许子类覆盖某些步骤，而 NVI 则确保所有的交流都通过一个中间人进行，提高了代码的稳定性和安全性。    



