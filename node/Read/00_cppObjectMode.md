## 对象


### 简单对象模型  
**A Simple Object Model**   


在简单对象模型设计中，对象不直接存放方法的方法与属性，而是存放指向存放对应方法、属性的空间的指针。  

这一设计好处在于设计编译器时比较节约脑细胞，即 `对象大小 == （方法数+属性数）*指针大小`。   
缺点在于多一个查找指针行为会拖慢速度，而且增加存储压力。  

*此设计思想并未在实际产品中被运用，但是它提供了“指向成员的指针”这一思路。*

![简易对象模型](./img/00_cppObjectMode/1.PNG ':size=WIDTHxHEIGHT')

### 表格驱动对象模型 

**A Table-driven Object Model**  

表格驱动对象模型将一个类的成员分为两类：data member（属性）与member function（方法）。  
并分别为两类成员建立表data member table（属性表）与表member function table（方法表）。   

属性表直接存储属性本体。方法表存放指针，而指针指向存放方法的空间。   

这一结构的优点在于间接性，即，改变类的设计增加删除各类属性都和已有程序中的对象并不产生直接关联。因为对象中只存放了两表的指针，天塌下来看不见，从而节约编译时间。   
缺点就是程序效率被拖的更慢了，对于方法来说，一次调用需要两次寻址。

*此设计并未被实际采用，但是“表”一概念却被用于虚函数的存储架构设计。*

![表格驱动对象模型](./img/00_cppObjectMode/2.PNG ':size=WIDTHxHEIGHT')


### C++对象模型  

**The C++ Object Model**    

在这个设计模型中，只有非静态属性被存放于对象本体中。其余的，即 静态属性、静态方法、非静态方法都只保存指针给予指向，而对于虚函数来说，其使用表格模型方式进行管理。   


这个方法大抵是保证了空间和存储时间的优化，缺点在于当类的非虚函数成员发生删减时就会发生对象改变从而重新编译。  

> C++对象模型对于虚函数的存储设计  

对于virtual function，C++对象模型使用“表格对象模型”思想对其进行规划。  

对于对象的虚函数的存储结构来说，一个名为virtual table（简称vtbl）的表格其内部保存一系列指向对象的虚函数的指针。而对象添加一个被称为vptr的指针，其只管指向vtbl。    

其中，vptr由 构造函数、析构函数、拷贝构造函数管控。

![c++对象模型](./img/00_cppObjectMode/3.PNG ':size=WIDTHxHEIGHT')


### 策略性正确的struct

> C中的部分技巧是C++的陷阱

C中存在一个技巧，即在结构体的末尾写上一个单一类型数组，就能获得一个可变长数组。其原理在于C中对于结构体的在内存的存储由声明顺序排列。
分析使用代码。  
malloc函数所做的仅仅是开辟一片指定大小的内存空间并返回内存首地址，`(struct mumble*)`触发类型强制转换而类型发生改变，而实际上这块内存是要比mumble类型要大的，但是不管，就是转。  
strcpy函数所做的仅仅是内存中数据的拷贝，有没有越界它真就不管，就硬拷。在C中结构体于内存中按声明顺序排布与声明时强制取巧分配更大内存的双向加持下，这个行为居然不会产生实际的越界。   

而C对于数组名为首地址 此指针解释之灵活更助长了此一恶行。

*我的评价是：这样写代码的程序员应该被拉去坐牢。*

```C
struct mumble
{
      /* stuff */
      char pc[1];  
};
    
//从文件或标准输入装置中取得一个字符串
//然后为struct 本身和该字符配置足够的内存
 
struct mumble * pmumbl = (struct mumble*)
             malloc(sizeof(struct mumble) + strlen(string) +1);
strcpy(&mumble.pc,string);
```

### 指针的本质

```c++
std::string *str;
int *val;
```

对于如上两个指针，其本质的不同到底是什么呢？大小？不不不，指针永远只占四个字节。所保存的内容？也不对，**任何指针所保存的都是某个内存块的首地址**。   
那么不同类型的指针其最本质的区别到底是什么？  
答案是，**寻址范围**。   

指针与指针最本质的区别就是寻址范围。

气氛都烘托到这了，必须狠狠的继续解答疑惑————为什么我有`void*`指针却不让直接使用？一定要转换类型？    
答案也许是显而易见的，**void*不知道自己要寻址多少距离！**

### 多态的实现原理

> 派生类在内存中存储的本质  

当不显式的在**派生类**构造函数指明父类构造函数时，编译器会隐式的在**派生类**构造函数中补上其基类的默认构造函数。 如此，沿着派生链依次向上绽放基类的构造函数。    

可以知道，一个派生类其占用的内存 大小是固定的，具体大小为`基类所占内存空间+派生类额外大小 = 派生类所占内存空间`。  

当一个指针指向一个对象时，本质的来说，它指向的是此对象内存空间的首地址。这里注意一个概念，即，内存是有首有尾，有前有后的。  
那么对于一个处于面向对象程序设计范式的派生类而言，其在内存中是怎么排布的，可有特定顺序？  
有！在内存中编译器将会沿着派生链去构造对象。  

> 为什么基类指针可以接收一个派生类对象   

*指针与指针区别的本质是什么？*   
答：**指针与指针的区别在于寻址范围不同。**，例如一个自定义类型`class FENGYE`其对象实体占用32字节内存空间，而内置类型int占有4个字节。   
现有`FENGYE *`与`int *`,其两者指针本体大小都为两字节，其保存的内容都为一片内存空间的首地址。实际上，其二者最本质的区别是，对于`FENGYE *`来说，其会寻找自己所保存的内存首地址向后的32个字节空间。`int *`只会寻找4个字节。   

将此问题套用到派生关系，上面小节论述了两个问题————其一是派生类大小 == 基类所占内存空间+派生类的额外大小，其二是在内存空间中，派生类的内存分布根据派生链顺序分布构造。   

一个困扰许久的问题就迎刃而解————为什么基类指针获取派生类对象的时候不能调用派生类的额外成员。 答案就是！找不到！！！基类指针的寻址范围不足以覆盖派生类所占的空间。          
如下图`class B: public A;`  类B派生于类A，且类A位于继承链的顶端。   

![指针寻址](./img/00_cppObjectMode/4.PNG ':size=WIDTHxHEIGHT')



回忆虚函数实现问题，编译器通过构造vptr从而指向虚表virtual function table，而virtual function table中存放有指针去指向具体的虚函数实现。这就是基类指针保存子类实现，调用有子类重写的虚函数时调用的是子类版本的原因了，当派生类本体在被构建时，`virtual function table`中虚函数的指向指向于子类的最新实现。  

这就是C++对于多态的实现的本质。   


### 为什么指针可以实体不可以？   

更详细的展开一下标题：在使用面向对象多态时，为什么派生类必须绑定于基类指针而非基类实体？  
```c++
A  a1 = new B();   // 值拷贝 会产生切削
A *a2 = new B();   // 址拷贝 分毫不损
```

本质是清晰可见的：即地址拷贝时，类A作为基类必然是吃不下一个派生类类B的。这里的拷贝是有损的，会产生切削的。  
问题再来了，即使a1强行有损的吃下了类B的这片空间，那么a1调用有B类实现的虚函数时调用的是类A版本还是类B版本（多态会不会触发）？   
答案是，多态不会被触发，调用的将会是类A的版本。唉？奇怪，明明按照规则来说即使有损切割，vptr也是存放在基类里的啊？  
其实是编译器的保护规则————它不能容忍一个有损拷贝行为来触发面向对象范式！。   

而对于指针来说，它就是一个纯纯粹粹的表征寻址范围与存储头文件的工具，对于其来说变换寻址范围与对象本体又有何损？   

## 构造函数语义学


程序也许未必会按照程序员书写的节奏稳步运行，编译器不仅仅可能会曲解程序员的本意，也有将一个意外书写错误过度解读为正确。更常有的情况是，编译器隐式优化，补全现有的代码。   

于本章节你将会看到即使是最简单最基础的操作，也许编译器都会对之有另一番奇妙解读与改写。


### 构造函数下编译器的隐式行为   

事实是，在某些特定情况下，编译器认为它应该为你的构造函数补上一些额外的操作，以保证对象的正常构造。    

什么是所谓的特定情况？其实说白了也就四种情况，容我在下面一一解释。   

1. 当此类型含有一个或以上类类型成员时。   
2. 当此类型为派生类，且父类有默认构造函数的时。
3. 当此类型重写或设定一个或以上虚函数时。
4. 当此类含有virtual base Class 时。   


>  1. 当此类型含有一个或以上类类型成员时   

不问为什么，先说一个事实。不论如何，对于**型含有一个或以上类类型成员**的类型的任何构造函数（无论是合成的还是任何一个自实现的）。   
编译器都会隐式的在构造函数的入口处，在任何构造函数中的代码之前去 隐式的调用类成员的默认构造函数。   

```c++
class Demo {

public:
    Demo(){
        std::cout << "HELLOW WORLD";
    };
    std::String str;
    std::String str2;
}

// 而实际的Demo的构造函数会是这样子的。   
Demo(){
    // 你看不到，但是编译器就是做了
    str = std::String();
    st2 = std::String();

    std::cout << "HELLOW WORLD";
}
```

问题一: 既然无论如何这个行为都会发生，那么我能决定编译器调用某一构造函数而非是默认构造函数吗？    
```QUESTION
答案是肯定的，通过列表初始化来设定。   
从本质上来说，所谓的列表初始化就是改隐式调用为你在列表中决定的目标初始化方式。    
```

问题二：多个对象都会被编译器隐式初始化对不对，那这个初始化必然有先后，这个先后是谁来决定的。
```QUESTION   
这个问题很关键，决定实际的编译器调用顺序并非是由列表初始化书写顺序来决定。   
实际上这个顺序是由属性在类中的声明顺序来决定的。   
所以，当一个类成员作为另一个类型的初始化时的基准时（最好别这么干），脑子需要清醒一点。    
```

> 2. 当此类型为派生类，且父类有默认构造函数的时。   

一个派生类空间组成由 `基类实现+派生类自己额外实现` 组成。 基类的空间由谁来进行构建？答案必然是由基类自己的构造函数。   
编译器同样隐式补全你的代码，补全内容为调用基类构造函数以达成基类空间的构造。  
相同于前面讲述的“面对类成员”的情形，这个隐式行为仍然发生于进入构造函数一瞬间，同样也会受到构造函数初始化列表所影响。


问题一：编译器隐式行为的先后顺序————先执行基类的构造函数还是先初始化成员？

```QUESTION
答案是，编译器先执行基类的构造函数。
```

> 3. 当此类型重写或设定一个或以上虚函数时。

可以知道，虚函数实现的本质是虚表（virtual function table）的重新指向，而类的对象仅仅使用指针vptr链接对应虚表实现。  

那么vptr指针由谁实现，在什么时候实现。答案在这里揭晓，即vptr指针由编译器实现，在构造发生时实现。   

同理，此行为编译器隐式执行之于构造函数入口，其自动补全。   



> 4. 当此类含有virtual base Class 时。 

此实现与base class 导致的隐式调用基类构造函数并不是一个概念。   
回到上一章节所讲述的内容，得知因为virtual base Class的实体偏移量未知，所以需要其派生类实现一个指针指向它，使得在编译时期可以对其进行查找。

同理，此行为编译器隐式执行之于构造函数入口，其自动补全。   




> 总结    

以上四种情况是有且仅有的编译器在构造函数中能为我们做的所有的补全操作了，编译器认为仅仅对于以上事件的处理是编译器的分内之事。   
除此之外，即使为指针成员赋一个nullptr编译器也是不肯的。


纠正以往的两个思维误区：   
1. 任何类，编译器不定义default construct 时，就会被合成出一个来。    
2. 被合成出的default construct会默认设定其中的每一个值。    


### 拷贝构造函数解读   

其实，当一个类符合位拷贝性质(bitwises copy construct)时，类间拷贝不需要使用拷贝构造函数，只需要一个一个的转移值即可。   

位拷贝性质会在四种情况下被打破：  

1. 当类有对象成员时  

需要用拷贝构造函数调用对象成员的拷贝构造函数。   

2. 当类有基类对象时   

需要用拷贝构造函数调用基类空间的拷贝构造函数。   

3. 当类拥有虚函数或重写某一虚函数  

已知vptr指针是存放于基类空间的。  
且知当一个基类对象接受一个派生类时候发生会发生切割，切割则直接舍弃掉多余的部分。     
你能想象一个基类的实现指向一个超出它认知的方法？这是实实在在且毫无余地的切割。    
拷贝构造函数在这里就会隐式的解决这个问题，让vptr回归它的认知极限。    

4. 当为一个虚继承基类的派生类时   

派生类因为用指针反指基类来完成对base virtual class定位。这个用于定位的指针也是类中的一个隐式属性。如果暴力拷贝就把别人的base virtual class拷贝过来了.......  


### 初始化列表的解读   

> 1）初始化行为必然发生，列表只是决定行为的具体方式，不写填表就会调用默认   

不多说，一切不言自明。

> 2）隐式的初始化顺序不按照列表的填写顺序，而是按照类中data members申明顺序   

这个也很好理解，只是当使用一个成员作为另一个成员的初值时，最好不要用填写初始化列表的方式赋值。   

> 3） vptr、基类空间...这些隐士成员在什么时候构造？   

隐式成员的初始化是排在最前面的。    
所以在填写初始化列表时不要用类成员去对基类进行初始化。   

## Data语义学

### 影响一个类大小因素   


一个类可能比你所以为的更大，其不仅受到系统的限制，还因为要完成诸多功能而拥有一些隐式成员。   


1. 支持virtual function体系的vptr指针   
2. 支持virtual base class所产生的额外指针  
3. alignment限制下的内存对齐，32位系统要求类的大小被4bits整除，64系统则8bits整除 
4. 所有的基类部分所占大小


### Data Member 的存取入手   

Data Membar 的存取成本受到其成分而定，总体而言分为如下。   

* static Member  
* no static Member 
* 从某一base class 派生而来  
* 多重继承的虚继承  



>  1. static Member   


 static Member  被视为仅在类中可见的global变量，操作其并不会在空间时间上产出额外负担。static Member的唯一实体存放于data segment之中，每次对此变量的存取都会变为对唯一实体的直接操作。   

 **所以，无论怎么存取此类变量都可以认为是语法上的便利行事，实际的调用会被编译器优化为data segment中某一实体的直接操纵。**       

 当然，如果所有类的 static Member 都存放于 data segment如何处理两个类同名static Member问题？     
 编译器会对static Member进行编码使得其独一无二，总之无非是用算法推导出独一无二的名称。  

 > 2. NoStatic Data Member   

NoStatic Data Member 实际上是存在于类的内部，对NoStatic Data Member 的直接操作其本质是在调用class 的首地址加上NoStatic Data Member 在类中的偏移量完成。   

```c++
// 对于 origin.y_  地址的计算过程
&(origin.y) == &origin + (&origin.y-1)
```

### 继承下的派生类结构  


C++的特性中，一个派生类会完整的保存其整个基类，这个完整是绝对的完整，甚至包括了内存对齐部分。   
为什么要包含内存对齐的部分内存呢？ 简单的说法，我可以从一个派生类中仅仅剥离出基类，如果不包含内存对齐就会将派生类的一部分拷贝过去。    

继承下的派生类，其起始地址放置的是派生类的基类，以此向下，派生类本体为继承链的底端同内存的尾端。  

> 多重继承下的内存分布  

多重继承下，类任然呈现内存连续紧密排布，有声明多重继承语法所决定。  


